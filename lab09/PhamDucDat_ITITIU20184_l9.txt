Name: Pham Duc Dat
ID: ITITIU20184

I. Lab Activity: Threads: Introductory: Lost-Update 1
- Q1: If the initial value of the data field is 1000, and one thousand increment updates are performed, each incrementing the value by 1, the final value should be 2000.
- Q2: After clicking the ‘Start ADD Thread’ button and running it in isolation, the result should be as expected, with the final value being 2000. If it's not, there might be a calculation error.
- Q3: Now with the current value at 2000, if one thousand decrement updates are performed, each decrementing the value by 1, the final value should return to 1000.
- Q4: After clicking the ‘Start SUBTRACT Thread’ button and running it in isolation, the result should be as expected, with the final value being 1000. If it's not, the decrement operation may not have been applied correctly.
- Q5: If the threads are run sequentially as described, there should be no issues of access leading to data corruption. Each thread completes its task before the next starts, avoiding any conflict or concurrent modifications.
- Q6: Starting again from 1000, if you perform one thousand increments and then one thousand decrements (or vice versa), sequentially or without interference, the final value should logically remain 1000.
- Q8: Once both threads have finished, ideally, both should have executed 1000 transactions, and the final value should be 1000. However, if they run concurrently without proper locking mechanisms, you might observe a different value due to the 'lost-update' problem where one thread’s update overwrites the other without considering changes made by the other thread. This discrepancy would be due to missing or improperly applied locks, causing race conditions.

II. Lab Activity: Threads: Introductory: Lost-Update 2
- Q1: In database systems, transactions are used to manage complex operations that involve multiple steps or queries. Each transaction should be atomic, consistent, isolated, and durable (ACID). The lost-update problem relates closely to these transactions, especially in terms of isolation. Without proper lock controls or transaction management, a transaction might read an old value and write back an incorrect one because another transaction modified the data concurrently.
- Q2: Primarily, the Isolation property is violated because the changes made by one transaction are visible to and affect other transactions before they are completed. Depending on the scenario, Consistency could also be compromised if the lost updates result in invalid data states.
- Q3: 
+ Online Flight Booking System: Lost updates could lead to overbooking of seats. If two users are allowed to book a seat simultaneously, one user's booking might overwrite another's.
+ Warehouse Stock-Management System: If two clerks adjust stock levels based on the same initial data, one clerk’s update might overwrite the other’s, resulting in incorrect inventory counts, potentially leading to stock shortages or surpluses.
- Q4: A real-time banking system where multiple transactions (withdrawals, deposits) are processed concurrently. Lost updates can result in incorrect account balances, leading to significant financial discrepancies.
- Q5: The actual discrepancy might seem random due to the nature of thread scheduling and execution timing, which are dependent on the operating system and the runtime conditions.
- Q6: The random element comes from the operating system’s thread scheduling and how the threads are executed. Since there’s no synchronization, the timing of thread execution can cause different results, depending on which thread gets more CPU time and how they interact with the shared variable.
- Q7: If the discrepancy is predictable, it might be easier to develop workarounds but it indicates a systemic issue in the application design. An unpredictable discrepancy, however, suggests non-deterministic behavior which can be harder to diagnose and fix, making it more severe as it could lead to inconsistent and unreliable application performance.

III. Lab Activity: Threads: Introductory: Locks 1
- Q1: Yes, a locking mechanism can indeed be the answer to preventing the lost-update problem. Locks ensure that when one thread is accessing or modifying a shared variable, other threads are blocked from doing the same until the lock is released. This synchronization tool helps in maintaining data integrity by preventing concurrent access to critical sections of code.
- Q2: Locks need to be applied to both threads involved in accessing the shared variable to prevent lost updates. If only one thread is locked, the other thread can still access the shared variable concurrently, leading to possible lost updates or data corruption.
- Q3: Considering the transaction involves reading, modifying, and writing back to a shared variable, both read and write operations must be locked. This is typically handled by a write-lock (or exclusive lock), which prevents other threads from reading or writing the shared variable while the lock is held. Preventing both reading and writing during the transaction ensures that no other thread can access the inconsistent state of the data.
- Q4: The lock should be applied before the transaction reads the current value into thread-local storage. This ensures that the entire read-modify-write cycle is protected from external interference, maintaining the transaction's integrity from start to finish.
- Q5: The lock should be released after the transaction has written the new value back to the shared variable. This makes the new, correct value available for other threads to read or modify, ensuring data consistency across the system.
- Q6: Through your experiments, you need to find a combination where the lock is applied before any transaction begins and released after the transaction completes. Repeating these settings multiple times should confirm the effectiveness of the strategy. If consistently no discrepancies are noted, then the strategy is likely effective.
- Q7: "When we say that using a lock enforces 'mutually exclusive access' to a variable, it's like saying only one person can use the only key to a room at a time. Imagine a room where a precious painting is being restored. If two restorers tried to work on it at the same time without coordination, they could mess up each other’s work. By locking the door while one restorer is inside, we ensure that no one else can enter and interfere until the first one is done and unlocks the door. This is what we do in programming with shared variables—using a lock means that only one piece of the program (or thread) can access or change the variable at a time, preventing any mix-ups or conflicts in the data."
- Q8: "Mutual exclusion is like a rule at a turnstile: one person can pass at a time. In the context of programming, when two threads (like two people wanting to pass through a turnstile) want to update the same data (pass through), mutual exclusion ensures that the first one completes its updates without the second one starting. This way, there’s no chance for the second thread to start updating based on old data before the first one finishes, which could otherwise lead to a 'lost update'—where changes made by the first thread are overwritten or lost because the second thread didn't see them. By enforcing this rule, we make sure everyone's changes are accounted for and nothing gets lost in translation."




